# Component Guidelines

This section outlines the standards for building consistent, accessible, and maintainable components within the **UI Kit** â€” covering structure, styling, testing, and documentation best practices.

## Structure

Each component should follow the structure below:

```bash
HvComp/
â”œâ”€â”€ index.ts            # Entry file with public exports
â”œâ”€â”€ HvComp.tsx          # Component implementation and types
â”œâ”€â”€ HvComp.stories.tsx  # Storybook stories and documentation
â”œâ”€â”€ HvComp.styles.ts    # Styling utilities and class definitions
â””â”€â”€ HvComp.test.tsx     # Unit tests
```

- Components and their types **must be exported** in `index.ts`.
- Use **PascalCase** for component names and **prefix with `Hv`** (e.g., `HvButton`, `HvAccordion`).
- Boolean props should be **opt-in** â€” default value should be `false`.
- Name event handler props using the `on<Action>` convention (e.g., `onClick`, `onChange`).

## Styles

- Use the `createClasses` utility to define component classes.
- Class names generated by `createClasses` are **exposed to users**, so choose names thoughtfully:
  - Always apply `classes.root` to the root element.
  - When targeting non-root elements, make the purpose clear (e.g., `classes.label`, `classes.iconContainer`).
  - For conditional styles, use descriptive names that reflect the condition.
- Avoid hard-coded styles. Always use the design **theme** (e.g., colors, spacing) for consistency.

## Documentation

- Create a corresponding `HvComp.stories.tsx` file using CSF (Component Story Format).
- The primary example should be named **`Main`**, with controls configured appropriately.
- Include only **meaningful and distinct stories** â€” avoid repetitive examples.

## Other Conventions

- Write unit tests using [`@testing-library/react`](https://testing-library.com/docs/react-testing-library/intro/).
- Use **semantic HTML** elements whenever possible for better accessibility and performance.
- Ensure components meet [WCAG](https://www.w3.org/WAI/WCAG21/quickref/) requirements and follow [ARIA guidelines](https://www.w3.org/TR/wai-aria/).

Following these guidelines helps maintain a coherent developer experience across the library and ensures consistency, accessibility, and long-term maintainability.

## Example

Here's an example anatomy of a `HvComp` component:

```ts
// HvComp.styles.ts
import { createClasses } from "@hitachivantara/uikit-react-utils";

export const { staticClasses, useClasses } = createClasses("HvComp", {
  /** Applied to the root element */
  root: {
    // leverage the ğŸ‘‡ `theme.` object
    padding: theme.spacing("xs"),
    backgroundColor: theme.colors.backgroundColor,
  },
  /** Applied to the root element when selected */
  selected: {},
  /** Applied to the root element when disabled */
  disabled: {
    // ğŸ‘‡ leverage global `disabled` instead of adding a `buttonDisabled`
    "& $button": {
      cursor: "not-allowed",
    },
  },
  /** Applied to the button element */
  button: {},
});
```

```tsx
// HvComp.tsx
import {
  useDefaultProps,
  type ExtractNames,
} from "@hitachivantara/uikit-react-utils";

import { HvBaseProps } from "../types/generic";
import { staticClasses, useClasses } from "./MyComp.styles";

// export `staticClasses` ğŸ‘‡ as `compClasses` (camelCase, no `Hv`)
export { staticClasses as compClasses };

// export the classes ğŸ‘‡ inferred from `useClasses`
export type HvCompClasses = ExtractNames<typeof useClasses>;

// extend the types to where `...others` ğŸ‘‡ is being passed
export interface HvCompProps extends HvBaseProps<HTMLDivElement> {
  // ğŸ‘‡ name boolean props so its obvious they're boolean
  selected?: boolean;
  // ğŸ‘‡ add JSDoc to the props, especially if they're complex
  /** Disables the component visually and its controls */
  disabled?: boolean;
  children?: ReactNode;
  // Use permissive ğŸ‘‡ `ReactNode` for props that are rendered as-is
  buttonContent?: ReactNode;
  // re-use types ğŸ‘‡ when possible
  onClick?: HvButtonProps["onClick"];
  // ğŸ‘‡ call handlers `on<Action>` or `on<Element><Action>` for sub-elements
  onButtonClick?: HvButtonProps["onClick"];
  // ğŸ‘‡ âŒ don't add redundant types (included in the parent interface)
  id?: string;
}

// ğŸ‘‡ Add a JSDoc block to the component explaining its purpose
/** HvComp does some amazing stuff */
export const HvComp = forwardRef<
  // no-indent
  React.ComponentRef<"div">,
  HvCompProps
>(function HvComp(props, ref) {
  const {
    children,
    // fix collisions ğŸ‘‡ by renaming to `<x>Prop`
    classes: classesProp,
    className,
    // ğŸ‘‡ make booleans be opt-in (default is false/undefined)
    selected,
    // ğŸ‘‡ don't  set defaults (ie `false`) unnecessarily
    disabled,
    buttonContent,
    onClick,
    onButtonClick,
    // ğŸ‘‡ call remaining props `others`
    ...others
    // use the ğŸ‘‡ useDefaultProps utility
  } = useDefaultProps("HvComp", props);
  // use the useClasses utility ğŸ‘‡
  const { classes, css, cx } = useClasses(classesProp);

  // internal state variables.
  const canSelect = !disabled && !selected;
  // reserve `useMemo` for expensive ğŸ‘‡ computations
  const hasElement = useMemo(() => expensiveSearch(children), [children]);

  // AVOID useEffect...
  useEffect(() => {
    // ğŸ‘‡ âŒ ...especially when dealing with event handlers
    onClick();
  }, [onClick]);

  // rename handlers ğŸ‘‡ (`handle<Action>`) and ğŸ‘‡ type them accordingly
  const handleButtonClick: HvButtonProps["onClick"] = (evt) => {
    evt.preventDefault();
    // use the ?. ğŸ‘‡ operator for optional event handlers & forward the event
    onButtonClick?.(evt);
  };

  // keep `render<Stuff>` as a `ReactNode` if possible
  // if you ğŸ‘‡ need `(props) => ReactNode`, it should likely be a separate component
  const renderContent = (
    <div>
      <span>{/* some content */}</span>
    </div>
  );

  return (
    <div
      // ğŸ‘‡ don't forget forwarding the ref
      ref={ref}
      // ğŸ‘‡ merge class names with `cx` provided by `useClasses`
      className={cx(
        // ğŸ‘‡ pass internal styles first, using `css`
        css(/* internal styles */),
        // ğŸ‘‡ ensure `classes.root` is on the root element
        classes.root,
        {
          // conditional classes ğŸ‘‡ are based on their *condition*
          [classes.selected]: selected,
          [classes.disabled]: disabled,
        },
        // ğŸ‘‡ pass user-defined `className` last
        className,
      )}
      onClick={disabled ? undefined : onClick}
      // ğŸ‘‡ forward others according to the types
      {...others}
    >
      <HvButton className={classes.button} onClick={handleButtonClick}>
        {buttonContent}
      </HvButton>
      {selected && renderContent}
      {children}
    </div>
  );
});
```
