# Component Guidelines

This section outlines the standards for building consistent, accessible, and maintainable components within the **UI Kit** â€” covering structure, styling, testing, and documentation best practices.

## Structure

Each component should follow the structure below:

```bash
HvComp/
â”œâ”€â”€ index.ts            # Entry file with public exports
â”œâ”€â”€ HvComp.tsx          # Component implementation and types
â””â”€â”€ HvComp.test.tsx     # Unit tests
```

- Components and their types **must be exported** in `index.ts`.
- Use **PascalCase** for component names and **prefix with `Hv`** (e.g., `HvButton`, `HvAccordion`).
- Boolean props should be **opt-in** â€” default value should be `false`.
- Name event handler props using the `on<Action>` convention (e.g., `onClick`, `onChange`).
- Optionally move styles (`HvComp.styles.ts`), types (`types.ts`), or utils (`utils.ts`) into separate files when they grow too complex or are reused across components.

## Styles

- Use the `createClasses` utility to define component classes.
- Leverage the design `theme` variables (e.g., colors, spacing), avoiding hard-coded values when possible.
- Class names generated by `createClasses` are **exposed to users**, so choose names thoughtfully:
  - Always apply `classes.root` to the root element.
  - When targeting non-root elements, make the purpose clear (e.g., `classes.label`, `classes.iconContainer`).
  - For conditional styles, use descriptive names that reflect the condition (e.g. `classes.containerOpen`).

## Documentation

- Create a corresponding `comp.mdx` file under the `apps/docs/src` directory.
- Leverage the `Playground` component for the most common & relevant properties
- Include only **meaningful and distinct stories**, avoiding redundant examples.

## Other Conventions

- Write unit tests using [`@testing-library/react`](https://testing-library.com/docs/react-testing-library/intro/).
- Use **semantic HTML** elements whenever possible for better accessibility and performance.
- Ensure components meet [WCAG](https://www.w3.org/WAI/WCAG21/quickref/) requirements and follow [ARIA guidelines](https://www.w3.org/TR/wai-aria/).

Following these guidelines helps maintain a coherent developer experience across the library and ensures consistency, accessibility, and long-term maintainability.

## Example

Here's an example anatomy of a `HvComp` component:

```ts
// HvComp.styles.ts
import { createClasses } from "@hitachivantara/uikit-react-utils";
import { theme } from "@hitachivantara/uikit-styles";

export const { staticClasses, useClasses } = createClasses("HvComp", {
  /** Applied to the root element */
  root: {
    padding: theme.spacing("xs"), // ğŸ‘ˆ leverage the `theme.` object
    backgroundColor: theme.colors.backgroundColor,
  },
  /** Applied to the root element when selected */
  selected: {},
  /** Applied to the root element when disabled */
  disabled: {
    // ğŸ‘‡ leverage global `disabled` instead of adding a `buttonDisabled`
    "& $button": {
      cursor: "not-allowed",
    },
  },
  /** Applied to the button element */
  button: {},
});
```

```tsx
// HvComp.tsx
import {
  useDefaultProps,
  type ExtractNames,
} from "@hitachivantara/uikit-react-utils";

import { HvBaseProps } from "../types/generic";
import { staticClasses, useClasses } from "./MyComp.styles";

// export `staticClasses` ğŸ‘‡ as `compClasses` (camelCase without `Hv` prefix)
export { staticClasses as compClasses };

// export the classes ğŸ‘‡ inferred from `useClasses`
export type HvCompClasses = ExtractNames<typeof useClasses>;

// extend the types to where `...others` ğŸ‘‡ is being passed
export interface HvCompProps extends HvBaseProps<HTMLDivElement> {
  selected?: boolean; // ğŸ‘ˆ name boolean props so its obvious they're boolean
  /** Disables the component visually and its controls */
  disabled?: boolean; // ğŸ‘† add JSDoc to the props, especially if they're complex
  children?: React.ReactNode;
  buttonContent?: React.ReactNode; // ğŸ‘ˆ use `ReactNode` for props that are rendered as-is
  onClick?: HvButtonProps["onClick"]; // ğŸ‘ˆ re-use types when possible
  onButtonClick?: HvButtonProps["onClick"]; // ğŸ‘ˆ call handlers `on[<Element>]<Action>`
  id?: string; // ğŸ‘ˆ âŒ don't add redundant types (included in the parent interface)
}

// ğŸ‘‡ Add a JSDoc block to the component explaining its purpose
/** HvComp does some amazing stuff */
export const HvComp = forwardRef<
  // no-indent
  React.ComponentRef<"div">,
  HvCompProps
>(function HvComp(props, ref) {
  const {
    children,
    classes: classesProp, // ğŸ‘ˆ fix collisions by renaming to `<x>Prop`
    className,
    selected, // ğŸ‘ˆ make booleans be opt-in (default is false/undefined)
    disabled, // ğŸ‘ˆ don't  set defaults (ie `false`) unnecessarily
    buttonContent,
    onClick,
    onButtonClick,
    ...others // ğŸ‘ˆ call remaining props `others`
  } = useDefaultProps("HvComp", props); // ğŸ‘ˆ use the useDefaultProps utility
  const { classes, css, cx } = useClasses(classesProp);

  // reserve `useMemo` for expensive ğŸ‘‡ computations
  const hasInput = useMemo(() => expensiveSearch(children), [children]);

  // rename handlers ğŸ‘‡ `handle<Action>` and ğŸ‘‡ type them accordingly, or ideally inline them
  const handleButtonClick: HvButtonProps["onClick"] = (evt) => {
    evt.preventDefault();
    onButtonClick?.(evt);
  };

  // keep `render<Stuff>` as a `ReactNode` if possible
  // if you ğŸ‘‡ need `(props) => ReactNode`, it should likely be a separate component
  const renderContent = (
    <div>
      <span />
    </div>
  );

  return (
    <div
      ref={ref} // ğŸ‘ˆ always forwarding the ref
      // ğŸ‘‡ merge class names with `cx` provided by `useClasses`
      className={cx(
        css(/* internal styles */), // ğŸ‘ˆ pass internal styles first, using `css`
        classes.root, // ğŸ‘ˆ ensure `classes.root` is on the root element
        {
          // conditional classes ğŸ‘‡ are based on their *condition*
          [classes.selected]: selected,
          [classes.disabled]: disabled,
        },
        className, // ğŸ‘ˆ pass user-defined `className` last
      )}
      onClick={disabled ? undefined : onClick}
      {...others} // ğŸ‘ˆ forward others according to the types
    >
      <HvButton className={classes.button} onClick={handleButtonClick}>
        {buttonContent}
      </HvButton>
      {selected && renderContent}
      {children}
    </div>
  );
});
```
